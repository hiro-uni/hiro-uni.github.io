---
title: "GGJ 2026 Countdown"
---

<!doctype html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GGJ 2026 Countdown - 広島Unity勉強会</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --ggj-yellow: #f1f22e;
            --ggj-logo: #BB1919;
            --ggj-purple: #553a65;
            --bbc-black: #000000;
            --bg-light: #f4f4f4;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: radial-gradient(circle at center, #ffffff 0%, #d5d5e5 100%);
            font-family: 'Inter', sans-serif;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .overlay {
            position: absolute;
            top: 50%;
            left: 5%;
            transform: translateY(-50%);
            z-index: 10;
            user-select: none;
            pointer-events: none;
        }

        .bbc-style-logo {
            display: flex;
            gap: 4px;
            margin-bottom: 0.5rem;
        }

        .logo-box {
            background: var(--bbc-black);
            color: white;
            font-weight: 900;
            font-size: 3rem;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .sub-logo {
            color: var(--ggj-logo);
            font-size: 4rem;
            font-weight: 900;
            letter-spacing: 2px;
            margin-top: -10px;
            text-shadow: 2px 2px 0px rgba(85, 58, 101, 0.3);
        }

        .location-tag {
            color: var(--ggj-purple);
            font-size: 1.2rem;
            font-weight: 700;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        .countdown-info {
            position: absolute;
            bottom: 5%;
            left: 5%;
            z-index: 10;
            color: #333;
        }

        .event-details {
            font-size: 1rem;
            font-weight: 700;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .target-date {
            font-size: 1.5rem;
            color: var(--ggj-purple);
            font-weight: 700;
        }

        @media (max-width: 768px) {
            .logo-box { width: 40px; height: 40px; font-size: 1.5rem; }
            .sub-logo { font-size: 2rem; }
            .location-tag { font-size: 0.8rem; letter-spacing: 2px; }
            .overlay { left: 50%; transform: translate(-50%, -150%); text-align: center; width: 100%; justify-content: center; display: flex; flex-direction: column; align-items: center; }
            .bbc-style-logo { justify-content: center; }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div class="overlay">
        <div class="bbc-style-logo">
            <div class="logo-box">G</div>
            <div class="logo-box">G</div>
            <div class="logo-box">J</div>
        </div>
        <div class="sub-logo">2026</div>
        <div class="location-tag">SETOUCHI in HIROSHIMA</div>
    </div>

    <div class="countdown-info">
        <div class="event-details">GGJ 2026 Setouchi in Hiroshima Starts In</div>
        <div id="countdown-text" class="target-date">00Days 00:00:00</div>
    </div>

    <script>
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
        import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';

        // --- Logic ---
        const targetDate = new Date('2026-01-30T17:00:00').getTime();
        const countdownElem = document.getElementById('countdown-text');

        function updateCountdownText() {
            const now = new Date().getTime();
            const distance = targetDate - now;

            if (distance < 0) {
                if (countdownElem) countdownElem.innerHTML = "JAM HAS STARTED!";
                return { days: 0, hours: 0, minutes: 0, seconds: 0 };
            }

            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);

            if (countdownElem) {
                countdownElem.innerHTML = `${days.toString().padStart(2, '0')}Days ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            return { days, hours, minutes, seconds };
        }

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        
        // Better background gradient using CSS and transparent renderer
        scene.background = null; 

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 6;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0x3498db, 0.8); // Softer blueish light
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);

        const spotLight = new THREE.SpotLight(0xffffff, 0.8);
        spotLight.position.set(-10, 5, 10);
        scene.add(spotLight);

        // --- The Globe (External Model) ---
        const globeGroup = new THREE.Group();
        scene.add(globeGroup);

        const gltfLoader = new GLTFLoader();
        let earthModel;

        gltfLoader.load('/assets/ggj/earth.glb', (gltf) => {
            earthModel = gltf.scene;
            
            // Apply blue vertical gradient transparency
            earthModel.traverse((child) => {
                if (child.isMesh) {
                    child.material.transparent = true;
                    // Inject custom shader logic for vertical transparency
                    child.material.onBeforeCompile = (shader) => {
                        shader.vertexShader = shader.vertexShader.replace(
                            '#include <common>',
                            `#include <common>
                             varying vec3 vWorldPos;`
                        );
                        shader.vertexShader = shader.vertexShader.replace(
                            '#include <begin_vertex>',
                            `#include <begin_vertex>
                             vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;`
                        );
                        shader.fragmentShader = shader.fragmentShader.replace(
                            '#include <common>',
                            `#include <common>
                             varying vec3 vWorldPos;`
                        );
                        // Modify alpha based on Y coordinate
                        // Assuming globe is around y=0 with radius ~2-3
                        shader.fragmentShader = shader.fragmentShader.replace(
                            '#include <opaque_fragment>',
                            `#include <opaque_fragment>
                             float grad = clamp((vWorldPos.y + 1.2) / 2.4, 0.0, 1.0);
                             gl_FragColor.a *= grad;`
                        );
                    };
                    
                    // Lighten the tint to let the texture show through more
                    if (child.material.color) {
                        child.material.color.setHex(0xaaccff); 
                    }
                    child.material.needsUpdate = true;
                }
            });

            // Adjust scale if needed (depends on the model)
            earthModel.scale.set(0.8, 0.8, 0.8);
            globeGroup.add(earthModel);
        });

        // --- Ribbons ---
        const ribbonsArr = [];
        const createRibbon = (radius, width, speed, color, opacity = 0.6) => {
            const ribbonGeom = new THREE.TorusGeometry(radius, width, 8, 128);
            const ribbonMat = new THREE.MeshPhongMaterial({ 
                color: color, 
                transparent: true, 
                opacity: opacity,
                shininess: 100
            });
            const ribbon = new THREE.Mesh(ribbonGeom, ribbonMat);
            ribbon.rotation.x = Math.random() * Math.PI;
            ribbon.rotation.y = Math.random() * Math.PI;
            scene.add(ribbon);
            ribbonsArr.push({ mesh: ribbon, speed: speed });
        };

        createRibbon(2.8, 0.04, 0.008, 0xf1f22e, 0.8); // GGJ Yellow
        createRibbon(3.1, 0.015, -0.012, 0x553a65, 0.6); // GGJ Purple
        createRibbon(2.6, 0.08, 0.004, 0xf1f22e, 0.3);
        createRibbon(3.5, 0.005, 0.02, 0x2cb4e8, 0.4); // GGJ Cyan

        // --- Rings (Waves) ---
        const wavesArr = [];
        const createWave = () => {
             const waveGeom = new THREE.RingGeometry(2, 2.02, 128);
             const waveMat = new THREE.MeshBasicMaterial({ color: 0xf1f22e, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
             const wave = new THREE.Mesh(waveGeom, waveMat);
             // Orient wave randomly or to camera
             wave.lookAt(camera.position);
             scene.add(wave);
             wavesArr.push({ mesh: wave, scale: 1, opacity: 0.8 });
        };

        // --- Floating Numbers ---
        let currentSecond = -1;
        let textMesh;
        const fontLoader = new FontLoader();
        let loadedFont;

        // Use a relative path for the font if possible or a more stable CDN
        const FONT_URL = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/fonts/helvetiker_bold.typeface.json';

        fontLoader.load(FONT_URL, (font) => {
            loadedFont = font;
            console.log("Font loaded");
        }, undefined, (err) => {
            console.error("Font failed to load", err);
        });


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            globeGroup.rotation.y += 0.003;
            
            ribbonsArr.forEach(r => {
                r.mesh.rotation.z += r.speed;
                r.mesh.rotation.x += r.speed * 0.2;
            });

            // Handle Timing
            const timeData = updateCountdownText();
            if (timeData && timeData.seconds !== currentSecond) {
                currentSecond = timeData.seconds;
                const lastDigit = currentSecond.toString().slice(-1);
                createWave();
            }

            // Animate Waves
            for (let i = wavesArr.length - 1; i >= 0; i--) {
                const w = wavesArr[i];
                w.scale += 0.03;
                w.opacity -= 0.015;
                w.mesh.scale.set(w.scale, w.scale, w.scale);
                w.mesh.material.opacity = w.opacity;

                if (w.opacity <= 0) {
                    scene.remove(w.mesh);
                    w.mesh.geometry.dispose();
                    w.mesh.material.dispose();
                    wavesArr.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

    </script>

</body>
</html>
