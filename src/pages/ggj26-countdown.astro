---
title: "GGJ 2026 Countdown"
---

<!doctype html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GGJ 2026 Countdown - 広島Unity勉強会</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style is:global>
        :root {
            --ggj-yellow: #f1f22e;
            --ggj-logo: #BB1919;
            --ggj-purple: #553a65;
            --bbc-black: #000000;
            --bg-light: #f4f4f4;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: radial-gradient(circle at center, #ffffff 0%, #d5d5e5 100%);
            font-family: 'Inter', sans-serif;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .overlay {
            position: absolute;
            top: 50%;
            left: 5%;
            transform: translateY(-50%);
            z-index: 10;
            user-select: none;
            pointer-events: none;
        }

        .bbc-style-logo {
            display: flex;
            gap: 4px;
            margin-bottom: 0.5rem;
        }

        .logo-box {
            background: var(--bbc-black);
            color: white;
            font-weight: 900;
            font-size: 3rem;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .sub-logo {
            color: var(--ggj-logo);
            font-size: 4rem;
            font-weight: 900;
            letter-spacing: 2px;
            margin-top: -10px;
            text-shadow: 2px 2px 0px rgba(85, 58, 101, 0.3);
        }

        .location-tag {
            color: var(--ggj-purple);
            font-size: 1.2rem;
            font-weight: 700;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        .countdown-info {
            position: absolute;
            bottom: 5%;
            left: 5%;
            z-index: 10;
            color: #333;
        }

        .event-details {
            font-size: 1rem;
            font-weight: 700;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .target-date {
            font-size: 1.5rem;
            color: var(--ggj-purple);
            font-weight: 700;
        }

        @media (max-width: 768px) {
            .logo-box { width: 40px; height: 40px; font-size: 1.5rem; }
            .sub-logo { font-size: 2rem; }
            .location-tag { font-size: 0.8rem; letter-spacing: 2px; }
            .overlay { left: 50%; transform: translate(-50%, -150%); text-align: center; width: 100%; justify-content: center; display: flex; flex-direction: column; align-items: center; }
            .bbc-style-logo { justify-content: center; }
        }

        /* City Labels Style */
        .city-label {
            color: #838383ff;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
            user-select: none;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 1s ease-in-out; 
        }
        .city-label.visible {
            opacity: 1;
        }
        .city-label.hiroshima-label {
            color: var(--ggj-logo);
            font-weight: 900;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div class="overlay">
        <div class="bbc-style-logo">
            <div class="logo-box">G</div>
            <div class="logo-box">G</div>
            <div class="logo-box">J</div>
        </div>
        <div class="sub-logo">2026</div>
        <div class="location-tag">SETOUCHI in HIROSHIMA</div>
    </div>

    <div class="countdown-info">
        <div class="event-details">GGJ 2026 Setouchi in Hiroshima Finish in</div>
        <div id="countdown-text" class="target-date">00Days 00:00:00</div>
    </div>

    <script>
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
        import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer.js';

        // --- Logic ---
        const targetDate = new Date('2026-02-01T17:00:00').getTime();
        const countdownElem = document.getElementById('countdown-text');

        function updateCountdownText() {
            const now = new Date().getTime();
            const distance = targetDate - now;

            if (distance < 0) {
                if (countdownElem) countdownElem.innerHTML = "Jam Has Finished!";
                return { days: 0, hours: 0, minutes: 0, seconds: 0 };
            }

            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);

            if (countdownElem) {
                countdownElem.innerHTML = `${days.toString().padStart(2, '0')}Days ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            return { days, hours, minutes, seconds };
        }

        // --- City Data & Helpers ---
        const cities = [
            { name: "Hiroshima", lat: 34.3853, lon: 132.4553 },
            { name: "Hokkaido", lat: 43.06417, lon: 141.34694 },
            { name: "Fukushima", lat: 37.75, lon: 140.46667 },
            { name: "Tokyo", lat: 35.6895, lon: 139.6917 },
            { name: "Saitama", lat: 35.85694, lon: 139.64889 },
            { name: "Kanagawa", lat: 35.44417, lon: 139.63806 },
            { name: "Aichi", lat: 35.18028, lon: 136.90667 },
            { name: "Okayama", lat: 34.66167, lon: 133.935 },
            { name: "Fukuoka", lat: 33.60639, lon: 130.41806 },
            { name: "Kumamoto", lat: 32.78972, lon: 130.74167 },
            { name: "Kagoshima", lat: 31.56028, lon: 130.55806 },
            { name: "Okinawa", lat: 26.2125, lon: 127.68111 },
            { name: "Kuala Lumpur", lat: 3.1390, lon: 101.6869 },
            { name: "Medan", lat: 3.5952, lon: 98.6722 },
            { name: "Singapore", lat: 1.3521, lon: 103.8198 },
            { name: "Makassar", lat: -5.1476, lon: 119.4327 },
            { name: "Jakarta", lat: -6.2088, lon: 106.8456 },
            { name: "Surabaya", lat: -7.2575, lon: 112.7521 },
            { name: "Darwin", lat: -12.4634, lon: 130.8456 },
            { name: "Perth", lat: -31.9505, lon: 115.8605 },
            { name: "Sydney", lat: -33.8688, lon: 151.2093 },
            { name: "Brisbane", lat: -27.4705, lon: 153.0260 },
            { name: "Tasmania", lat: -42.8821, lon: 147.3272 },
            { name: "Christchurch", lat: -43.5321, lon: 172.6362 },
            { name: "Wellington", lat: -41.2865, lon: 174.7762 },
            { name: "Auckland", lat: -36.8485, lon: 174.7633 },
            { name: "Invercargill", lat: -46.4132, lon: 168.3538 },
            { name: "Newcastle", lat: -32.9283, lon: 151.7817 },
            { name: "Windhoek", lat: -22.5597, lon: 17.0832 },
            { name: "Lusaka", lat: -15.3875, lon: 28.3228 },
            { name: "Kigali", lat: -1.9441, lon: 30.0619 },
            { name: "Abuja", lat: 9.0765, lon: 7.3986 },
            { name: "Accra", lat: 5.6037, lon: -0.1870 },
            { name: "Abidjan", lat: 5.3600, lon: -4.0083 },
            { name: "Cairo", lat: 30.0444, lon: 31.2357 },
            { name: "Casablanca", lat: 33.5731, lon: -7.5898 },
            { name: "Madrid", lat: 40.4168, lon: -3.7038 },
            { name: "Lisbon", lat: 38.7223, lon: -9.1393 },
            { name: "Caracas", lat: 10.4806, lon: -66.9036 },
            { name: "Bogota", lat: 4.7110, lon: -74.0721 },
            { name: "Quito", lat: -0.1807, lon: -78.4678 },
            { name: "La Paz", lat: -16.4897, lon: -68.1193 },
            { name: "Buenos Aires", lat: -34.6037, lon: -58.3816 },
            { name: "Rio Grande", lat: -53.7860, lon: -67.7073 },
            { name: "London", lat: 51.5074, lon: -0.1278 },
            { name: "Paris", lat: 48.8566, lon: 2.3522 },
            { name: "Libreville", lat: 0.3900, lon: 9.4500 },
            { name: "Tbilisi", lat: 41.7151, lon: 44.8271 },
            { name: "Berlin", lat: 52.5200, lon: 13.4050 },
            { name: "Athens", lat: 37.9838, lon: 23.7275 },
            { name: "Guatemala City", lat: 14.6349, lon: -90.5069 },
            { name: "Tegucigalpa", lat: 14.0818, lon: -87.2068 },
            { name: "Budapest", lat: 47.4979, lon: 19.0402 },
            { name: "Reykjavik", lat: 64.1265, lon: -21.8174 },
            { name: "New Delhi", lat: 28.6139, lon: 77.2090 },
            { name: "Tehran", lat: 35.6892, lon: 51.3890 },
            { name: "Baghdad", lat: 33.3152, lon: 44.3661 },
            { name: "Dublin", lat: 53.3498, lon: -6.2603 },
            { name: "Jerusalem", lat: 31.7683, lon: 35.2137 },
            { name: "Rome", lat: 41.9028, lon: 12.4964 },
            { name: "Kingston", lat: 17.9900, lon: -76.7900 },
            { name: "Amman", lat: 31.9539, lon: 35.9106 },
            { name: "Astana", lat: 51.1694, lon: 71.4491 },
            { name: "Nairobi", lat: -1.2921, lon: 36.8219 },
            { name: "Kuwait City", lat: 29.3759, lon: 47.9774 },
            { name: "Bishkek", lat: 42.8746, lon: 74.5698 },
            { name: "Riga", lat: 56.9496, lon: 24.1052 },
            { name: "Beirut", lat: 33.8938, lon: 35.5018 },
            { name: "Vilnius", lat: 54.6872, lon: 25.2797 },
            { name: "Luxembourg City", lat: 49.6117, lon: 6.1296 },
            { name: "Antananarivo", lat: -18.9137, lon: 47.5361 },
            { name: "Mexico City", lat: 19.4326, lon: -99.1332 },
            { name: "Washington, D.C.", lat: 38.9072, lon: -77.0369 },
            { name: "Beijing", lat: 39.9042, lon: 116.4074 },
            { name: "Taipei", lat: 25.0330, lon: 121.5654 },
            { name: "Hanoi", lat: 21.0285, lon: 105.8542 },
            { name: "Assam", lat: 26.1158, lon: 91.7086 },
            { name: "Mumbai", lat: 19.0760, lon: 72.8777 },
            { name: "Hong Kong", lat: 22.3193, lon: 114.1694 },
            { name: "Seoul", lat: 37.5665, lon: 126.9780 },
            { name: "Tianjin", lat: 39.0842, lon: 117.2010 },
            { name: "Wuhou", lat: 30.6433, lon: 104.0450 }
        ];

        function latLongToVector3(lat, lon, radius) {
            const phi = (90 - lat + 20) * (Math.PI / 180) ;
            const theta = (lon + 180 - 15) * (Math.PI / 180);
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const z = radius * Math.sin(phi) * Math.sin(theta);
            const y = radius * Math.cos(phi);
            return new THREE.Vector3(x, y, z);
        }

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        
        // Better background gradient using CSS and transparent renderer
        scene.background = null; 

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 6;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        container.appendChild(labelRenderer.domElement);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0); // Doubled intensity
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0x3498db, 1.2); 
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);

        const spotLight = new THREE.SpotLight(0xffffff, 1.2);
        spotLight.position.set(-10, 5, 10);
        scene.add(spotLight);

        // --- The Globe (External Model) ---
        const globeGroup = new THREE.Group();
        scene.add(globeGroup);

        const gltfLoader = new GLTFLoader();
        let earthModel;

        gltfLoader.load('/assets/ggj/earth.glb', (gltf) => {
            earthModel = gltf.scene;
            
            // Apply blue vertical gradient transparency
            earthModel.traverse((child) => {
                if (child.isMesh) {
                    child.material.transparent = true;
                    // Inject custom shader logic for vertical transparency
                    child.material.onBeforeCompile = (shader) => {
                        shader.vertexShader = shader.vertexShader.replace(
                            '#include <common>',
                            `#include <common>
                             varying vec3 vWorldPos;`
                        );
                        shader.vertexShader = shader.vertexShader.replace(
                            '#include <begin_vertex>',
                            `#include <begin_vertex>
                             vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;`
                        );
                        shader.fragmentShader = shader.fragmentShader.replace(
                            '#include <common>',
                            `#include <common>
                             varying vec3 vWorldPos;`
                        );
                        // Modify alpha based on Y coordinate
                        // Assuming globe is around y=0 with radius ~2-3
                        shader.fragmentShader = shader.fragmentShader.replace(
                            '#include <opaque_fragment>',
                            `#include <opaque_fragment>
                             float grad = clamp((vWorldPos.y + 1.8)  / 2.8, 0.1, 1.0);
                             gl_FragColor.a *= grad;`
                        );
                    };
                    
                    // Lighten the tint to let the texture show through more
                    if (child.material.color) {
                        child.material.color.setHex(0xeeeeff); // Much brighter tint
                    }
                    child.material.needsUpdate = true;
                }
            });

            // Adjust scale if needed (depends on the model)
            earthModel.scale.set(0.8, 0.8, 0.8);
            globeGroup.add(earthModel);
        });

        // --- Ribbons ---
        const ribbonsArr = [];
        const createRibbon = (radius, width, speed, color, opacity = 0.6) => {
            const ribbonGeom = new THREE.TorusGeometry(radius, width, 8, 128);
            const ribbonMat = new THREE.MeshPhongMaterial({ 
                color: color, 
                transparent: true, 
                opacity: opacity,
                shininess: 100
            });
            const ribbon = new THREE.Mesh(ribbonGeom, ribbonMat);
            ribbon.rotation.x = Math.random() * Math.PI;
            ribbon.rotation.y = Math.random() * Math.PI;
            scene.add(ribbon);
            ribbonsArr.push({ mesh: ribbon, speed: speed });
        };

        createRibbon(2.8, 0.04, 0.008, 0xf1f22e, 0.9); // GGJ Yellow (Brighter)
        createRibbon(3.1, 0.015, -0.012, 0x553a65, 0.8); // GGJ Purple (More opaque)
        createRibbon(2.6, 0.08, 0.004, 0xf1f22e, 0.5); // (More opaque)
        createRibbon(3.5, 0.005, 0.02, 0x2cb4e8, 0.6); // GGJ Cyan (More opaque)

        // --- Rings (Waves) ---
        const wavesArr = [];
        const createWave = () => {
             const waveGeom = new THREE.RingGeometry(2, 2.02, 128);
             const waveMat = new THREE.MeshBasicMaterial({ color: 0xf1f22e, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
             const wave = new THREE.Mesh(waveGeom, waveMat);
             // Orient wave randomly or to camera
             wave.lookAt(camera.position);
             scene.add(wave);
             wavesArr.push({ mesh: wave, scale: 1, opacity: 0.8 });
        };

        // --- Floating Numbers ---
        let currentSecond = -1;
        let textMesh;
        const fontLoader = new FontLoader();
        let loadedFont;

        // Use a relative path for the font if possible or a more stable CDN
        const FONT_URL = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/fonts/helvetiker_bold.typeface.json';

        fontLoader.load(FONT_URL, (font) => {
            loadedFont = font;
            console.log("Font loaded");
        }, undefined, (err) => {
            console.error("Font failed to load", err);
        });

        // --- City Animation Management ---
        const activeCities = new Map();
        const connectionLines = [];
        const EARTH_RADIUS = 2.4; // Matching the shader logic's assumed radius

        function updateCities() {
            // Ensure Hiroshima is always there
            if (!activeCities.has("Hiroshima")) {
                const hiroshima = cities.find(c => c.name === "Hiroshima");
                if (hiroshima) activateCity(hiroshima, true);
            }

            // Randomly add a city
            if (activeCities.size < 8 && Math.random() < 0.05) {
                const availableCities = cities.filter(c => !activeCities.has(c.name));
                if (availableCities.length > 0) {
                    const city = availableCities[Math.floor(Math.random() * availableCities.length)];
                    activateCity(city);
                }
            }

            // Cleanup old cities
            activeCities.forEach((data, name) => {
                if (name !== "Hiroshima" && Date.now() - data.startTime > 5000) {
                    deactivateCity(name);
                }
            });
        }

        function activateCity(city, persistent = false) {
            const pos = latLongToVector3(city.lat, city.lon, EARTH_RADIUS);
            
            // Label
            const div = document.createElement('div');
            div.className = 'city-label';
            if (city.name === "Hiroshima") div.classList.add('hiroshima-label');
            div.textContent = city.name;
            const label = new CSS2DObject(div);
            label.position.copy(pos);
            globeGroup.add(label);
            
            // Connect to another active city
            if (activeCities.size > 0) {
                const otherCities = Array.from(activeCities.values());
                const target = otherCities[Math.floor(Math.random() * otherCities.length)];
                createLine(pos, target.position);
            }

            activeCities.set(city.name, { 
                label, 
                position: pos, 
                startTime: Date.now(),
                div,
                persistent
            });

            // Trigger fade in
            setTimeout(() => div.classList.add('visible'), 50);
        }

        function deactivateCity(name) {
            const data = activeCities.get(name);
            if (data) {
                data.div.classList.remove('visible');
                setTimeout(() => {
                    globeGroup.remove(data.label);
                    activeCities.delete(name);
                }, 1000);
            }
        }

        function createLine(start, end) {
            const points = [];
            // Create a slightly arched path
            const mid = start.clone().lerp(end, 0.5).normalize().multiplyScalar(EARTH_RADIUS * 1.1);
            const curve = new THREE.QuadraticBezierCurve3(start, mid, end);
            const linePoints = curve.getPoints(20);
            
            const lineGeom = new THREE.BufferGeometry().setFromPoints(linePoints);
            const lineMat = new THREE.LineBasicMaterial({ 
                color: 0x999999, 
                transparent: true, 
                opacity: 0,
                linewidth: 1
            });
            const line = new THREE.Line(lineGeom, lineMat);
            globeGroup.add(line);
            
            const lineData = { line, startTime: Date.now(), opacity: 0 };
            connectionLines.push(lineData);
        }

        function updateLines() {
            for (let i = connectionLines.length - 1; i >= 0; i--) {
                const l = connectionLines[i];
                const age = Date.now() - l.startTime;
                
                if (age < 1000) {
                    l.opacity = age / 1000;
                } else if (age > 4000) {
                    l.opacity = 1 - (age - 4000) / 1000;
                } else {
                    l.opacity = 1;
                }

                l.line.material.opacity = l.opacity * 0.4;

                if (age > 5000) {
                    globeGroup.remove(l.line);
                    l.line.geometry.dispose();
                    l.line.material.dispose();
                    connectionLines.splice(i, 1);
                }
            }
        }


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            globeGroup.rotation.y += 0.003;
            
            ribbonsArr.forEach(r => {
                r.mesh.rotation.z += r.speed;
                r.mesh.rotation.x += r.speed * 0.2;
            });

            // Handle Timing
            const timeData = updateCountdownText();
            if (timeData && timeData.seconds !== currentSecond) {
                currentSecond = timeData.seconds;
                const lastDigit = currentSecond.toString().slice(-1);
                createWave();
            }

            // Animate Waves
            for (let i = wavesArr.length - 1; i >= 0; i--) {
                const w = wavesArr[i];
                w.scale += 0.03;
                w.opacity -= 0.015;
                w.mesh.scale.set(w.scale, w.scale, w.scale);
                w.mesh.material.opacity = w.opacity;

                if (w.opacity <= 0) {
                    scene.remove(w.mesh);
                    w.mesh.geometry.dispose();
                    w.mesh.material.dispose();
                    wavesArr.splice(i, 1);
                }
            }

            updateCities();
            updateLines();

            // Visibility Check for Labels
            const tempVector = new THREE.Vector3();
            const toCamera = camera.position.clone().normalize();
            activeCities.forEach((data, name) => {
                data.label.getWorldPosition(tempVector);
                tempVector.normalize();
                const dot = tempVector.dot(toCamera);
                
                // If dot < 0.2, the label is on the far side or too close to the edge
                if (dot < 0.15) {
                    data.div.style.display = 'none';
                } else {
                    data.div.style.display = 'block';
                }
            });

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            labelRenderer.setSize(width, height);
        });

    </script>

</body>
</html>
